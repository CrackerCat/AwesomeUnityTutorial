# 抽象类、接口、多态

多一层抽象，系统就多一层灵活，性能会稍减，但以现在硬件条件，影响不大

灵活性的直接影响：程序员少加班

## 1. 抽象类

### 1.1 抽象类概念

定义类时，使用 abstract 关键字，不能够被实例化的类，称为抽象类。

抽象类的用途是提供一个可供多个派生类共享的通用基类定义。 

``` C#
public abstract class A
{
    // Class members here.
}
```

抽象类也可以定义抽象方法。 方法是将关键字 abstract 添加到方法的返回类型的前面。 例如：

``` C#
public abstract class A
{
    public abstract void DoWork(int i);
}
```

### 1.2 抽象方法和虚方法

抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块。 

派生类中，如果要实现基类中的抽象方法，也需要使用 override 关键字

``` C#
public class B : A{
    public override void DoWork(int i)
    {
        Debug.Log($"i = {i}");
    }

}
```

抽象类的派实体生类必须实现所有抽象方法。 当抽象类从基类继承虚方法时，抽象类可以使用抽象方法重写该虚方法。 例如：

``` C#
// compile with: -target:library
public class D
{
    public virtual void DoWork(int i)
    {
        // Original implementation.
    }
}

public abstract class E : D
{
    public abstract override void DoWork(int i);
}

public class F : E
{
    public override void DoWork(int i)
    {
        // New implementation.
    }
}
```

如果将 virtual 方法声明为 abstract，则该方法对于从抽象类继承的所有类而言仍然是虚方法。 继承抽象方法的类无法访问方法的原始实现，因此在上一示例中，类 F 上的 DoWork 无法调用类 D 上的 DoWork。通过这种方式，抽象类可强制派生类向虚拟方法提供新的方法实现。

### 1.3 抽象属性

C# 的抽象类中，除了抽象方法外，还可以包含抽象属性，即在属性前，加上 abstract 关键字，取值器或赋值器就不能再写实现；派生类中，要实现其属性，也要使用 override 关键字

``` C#
public abstract class Person{
    protected int _age;
    protected string _name;

    public abstract int Age {get;}

    public abstract string Name {get;set;}
}

public class Student:Person{
    public override int Age{
        get{ return _age;}
    }
    public override string Name{
        get{return _name;}
        set{_name = value;}
    }

}
```

## 2. 接口


> 参考资料：
> 
> * [C# 官方文档 抽象类](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members)
> * [C# 官方文档 如何定义抽象属性](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-define-abstract-properties)